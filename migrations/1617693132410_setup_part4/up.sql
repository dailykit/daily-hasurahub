CREATE TABLE brands.brand (
    id integer DEFAULT public.defaultid('brands'::text, 'brand'::text, 'id'::text) NOT NULL,
    domain text,
    "isDefault" boolean DEFAULT false NOT NULL,
    title text,
    "isPublished" boolean DEFAULT true NOT NULL,
    "onDemandRequested" boolean DEFAULT false NOT NULL,
    "subscriptionRequested" boolean DEFAULT false NOT NULL,
    "isArchived" boolean DEFAULT false NOT NULL,
    "parseurMailBoxId" integer,
    "importHistoryId" integer
);
COMMENT ON TABLE brands.brand IS 'This table contains all the brands available in this instance.';
COMMENT ON COLUMN brands.brand.id IS 'Unique id of brand';
COMMENT ON COLUMN brands.brand.domain IS 'Domain at which this particular brand would be operating at.';
COMMENT ON COLUMN brands.brand."isDefault" IS 'This brand would be chosen incase any url is entered that does not correspond to any other brand';
COMMENT ON COLUMN brands.brand.title IS 'This is the title of the brand for internal purpose.';
COMMENT ON COLUMN brands.brand."isPublished" IS 'Whether the brand is published or not';
COMMENT ON COLUMN brands.brand."onDemandRequested" IS 'If this brand would be operating an ondemand store. If false, then opening /store link would redirect.';
COMMENT ON COLUMN brands.brand."subscriptionRequested" IS 'If this brand would be operating an subscription store. If false, then opening /subscription link would redirect.';
COMMENT ON COLUMN brands.brand."isArchived" IS 'if True, means that this brand is no longer active and user attempted to delete it.';
COMMENT ON COLUMN brands.brand."parseurMailBoxId" IS 'This is for parseur mailbox functionality.';
CREATE TABLE brands."brand_paymentPartnership" (
    "brandId" integer NOT NULL,
    "paymentPartnershipId" integer NOT NULL,
    "isActive" boolean DEFAULT true NOT NULL
);
COMMENT ON TABLE brands."brand_paymentPartnership" IS 'This is a many to many table for maintaining the different payment options available for each brand.';
COMMENT ON COLUMN brands."brand_paymentPartnership"."brandId" IS 'Id of the brand from the brand table.';
COMMENT ON COLUMN brands."brand_paymentPartnership"."paymentPartnershipId" IS 'id of the paymentPartnership from the dailycloak database table of paymentPartnership. This id represents which payment company and what are payment conditions to be used.';
COMMENT ON COLUMN brands."brand_paymentPartnership"."isActive" IS 'Whether this payment partnership is active or not.';
CREATE TABLE brands."brand_storeSetting" (
    "brandId" integer NOT NULL,
    "storeSettingId" integer NOT NULL,
    value jsonb NOT NULL,
    "importHistoryId" integer
);
COMMENT ON TABLE brands."brand_storeSetting" IS 'This is a many to many table maintaining Ondemand Store setting for available brands.';
COMMENT ON COLUMN brands."brand_storeSetting"."brandId" IS 'This is the brand id from brand table.';
COMMENT ON COLUMN brands."brand_storeSetting"."storeSettingId" IS 'This is the id from the list of settings available for ondemand.';
COMMENT ON COLUMN brands."brand_storeSetting".value IS 'This is the value of the particular setting for the particular brand.';
CREATE TABLE brands."brand_subscriptionStoreSetting" (
    "brandId" integer NOT NULL,
    "subscriptionStoreSettingId" integer NOT NULL,
    value jsonb
);
COMMENT ON TABLE brands."brand_subscriptionStoreSetting" IS 'This table maintains list of settings for subscription store for brands.';
COMMENT ON COLUMN brands."brand_subscriptionStoreSetting"."brandId" IS 'This is the brand id from the brand table.';
COMMENT ON COLUMN brands."brand_subscriptionStoreSetting"."subscriptionStoreSettingId" IS 'This is the id from the list of settings available for subscription store.';
COMMENT ON COLUMN brands."brand_subscriptionStoreSetting".value IS 'This is the value of the particular setting for the particular brand.';
CREATE TABLE brands."storeSetting" (
    id integer DEFAULT public.defaultid('brands'::text, 'storeSetting'::text, 'id'::text) NOT NULL,
    identifier text NOT NULL,
    value jsonb,
    type text
);
COMMENT ON TABLE brands."storeSetting" IS 'This lists all the available settings for ondemand store.';
COMMENT ON COLUMN brands."storeSetting".id IS 'This is autogenerated id of the setting representation available for ondemand.';
COMMENT ON COLUMN brands."storeSetting".identifier IS 'This is a unique identifier of the individual setting type.';
COMMENT ON COLUMN brands."storeSetting".value IS 'This is a jsonb data type storing default value for the setting. If no brand specific setting is available, then this setting value would be used.';
COMMENT ON COLUMN brands."storeSetting".type IS 'Type of setting to segment or categorize according to different use-cases.';
CREATE TABLE brands."subscriptionStoreSetting" (
    id integer DEFAULT public.defaultid('brands'::text, 'storeSetting'::text, 'id'::text) NOT NULL,
    identifier text NOT NULL,
    value jsonb,
    type text
);
COMMENT ON TABLE brands."subscriptionStoreSetting" IS 'This lists all the available settings for ondemand store.';
COMMENT ON COLUMN brands."subscriptionStoreSetting".id IS 'This is autogenerated id of the setting representation available for subscripton.';
COMMENT ON COLUMN brands."subscriptionStoreSetting".identifier IS 'This is a unique identifier of the individual setting type.';
COMMENT ON COLUMN brands."subscriptionStoreSetting".value IS 'This is a jsonb data type storing default value for the setting. If no brand specific setting is available, then this setting value would be used.';
COMMENT ON COLUMN brands."subscriptionStoreSetting".type IS 'Type of setting to segment or categorize according to different use-cases.';
CREATE TABLE content.identifier (
    title text NOT NULL,
    "pageTitle" text NOT NULL
);
CREATE TABLE content.page (
    title text NOT NULL,
    description text
);
CREATE TABLE content."subscriptionDivIds" (
    id text NOT NULL,
    "fileId" integer
);
CREATE TABLE content.template (
    id uuid NOT NULL
);
CREATE TABLE crm.brand_campaign (
    "brandId" integer NOT NULL,
    "campaignId" integer NOT NULL,
    "isActive" boolean DEFAULT true
);
COMMENT ON TABLE crm.brand_campaign IS 'This is a many to many table maintaining relationship between brand and campaigns.';
COMMENT ON COLUMN crm.brand_campaign."brandId" IS 'This is the brandId from the brand table.';
COMMENT ON COLUMN crm.brand_campaign."campaignId" IS 'This is campaign id from campaign table.';
COMMENT ON COLUMN crm.brand_campaign."isActive" IS 'Whether this particular campaign is active or not for this brand.';
CREATE TABLE crm.brand_coupon (
    "brandId" integer NOT NULL,
    "couponId" integer NOT NULL,
    "isActive" boolean DEFAULT true NOT NULL
);
COMMENT ON TABLE crm.brand_coupon IS 'This is a many to many table maintaining relationship between brand and coupons.';
COMMENT ON COLUMN crm.brand_coupon."brandId" IS 'This is the brandId from the brand table.';
COMMENT ON COLUMN crm.brand_coupon."couponId" IS 'This is coupon id from coupon table.';
COMMENT ON COLUMN crm.brand_coupon."isActive" IS 'Whether this particular coupon is active or not for this brand.';
CREATE TABLE crm.brand_customer (
    id integer DEFAULT public.defaultid('crm'::text, 'brand_customer'::text, 'id'::text) NOT NULL,
    "keycloakId" text NOT NULL,
    "brandId" integer NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    "isSubscriber" boolean DEFAULT false,
    "subscriptionId" integer,
    "subscriptionAddressId" text,
    "subscriptionPaymentMethodId" text,
    "isAutoSelectOptOut" boolean DEFAULT false NOT NULL,
    "isSubscriberTimeStamp" timestamp without time zone,
    "subscriptionServingId" integer,
    "subscriptionItemCountId" integer,
    "subscriptionTitleId" integer
);
COMMENT ON TABLE crm.brand_customer IS 'This table maintains a list of all the customers who have signed into this particular brand atleast once.';
COMMENT ON COLUMN crm.brand_customer.id IS 'Auto-generated id.';
COMMENT ON COLUMN crm.brand_customer."keycloakId" IS 'This is the unique id of customer given by keycloak.';
COMMENT ON COLUMN crm.brand_customer."brandId" IS 'This is the brandId from brand table.';
COMMENT ON COLUMN crm.brand_customer."isSubscriber" IS 'If this customer has subscribed to any plan on subscription store for this particular brand.';
COMMENT ON COLUMN crm.brand_customer."subscriptionId" IS 'This is the id of the subscription plan chosen by this customer.';
COMMENT ON COLUMN crm.brand_customer."subscriptionAddressId" IS 'This is the id of address from Dailykey database at which this plan would be delivering the weekly box to.';
COMMENT ON COLUMN crm.brand_customer."subscriptionPaymentMethodId" IS 'This is the id of payment method from Dailykey database defining which particular payment method would be used for auto deduction of weekly amount.';
CREATE SEQUENCE crm.brand_customer_id_seq
    START WITH 1000
    INCREMENT BY 1
    MINVALUE 1000
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE crm.brand_customer_id_seq OWNED BY crm.brand_customer.id;
CREATE TABLE crm."campaignType" (
    id integer DEFAULT public.defaultid('crm'::text, 'campaignType'::text, 'id'::text) NOT NULL,
    value text NOT NULL
);
CREATE TABLE crm.customer (
    id integer DEFAULT public.defaultid('crm'::text, 'customer'::text, 'id'::text) NOT NULL,
    source text,
    email text NOT NULL,
    "keycloakId" text NOT NULL,
    "clientId" text,
    "isSubscriber" boolean DEFAULT false NOT NULL,
    "subscriptionId" integer,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    "isTest" boolean DEFAULT false NOT NULL,
    "sourceBrandId" integer DEFAULT 1 NOT NULL,
    "isArchived" boolean DEFAULT false NOT NULL
);
COMMENT ON TABLE crm.customer IS 'This lists records of all the unique customers across all the brands.';
COMMENT ON COLUMN crm.customer.id IS 'Auto-generated id of the customer';
COMMENT ON COLUMN crm.customer.source IS 'From which source this customer was first created. If subscription or ondemand.';
COMMENT ON COLUMN crm.customer.email IS 'Unique email of the customer.';
COMMENT ON COLUMN crm.customer."keycloakId" IS 'This is the unique id of customer given by keycloak.';
COMMENT ON COLUMN crm.customer."isSubscriber" IS 'If this customer has subscribed to any plan on subscription store for any of the brand.';
COMMENT ON COLUMN crm.customer."isTest" IS 'If true, all the carts for this customer would bypass the payment.';
COMMENT ON COLUMN crm.customer."sourceBrandId" IS 'From which brand was this customer first signed up in the system.';
COMMENT ON COLUMN crm.customer."isArchived" IS 'Marks the deletion of customer if user attempts to delete it';
CREATE TABLE crm."customerReferral" (
    id integer DEFAULT public.defaultid('crm'::text, 'customerReferral'::text, 'id'::text) NOT NULL,
    "keycloakId" text NOT NULL,
    "referralCode" text DEFAULT public.gen_random_uuid() NOT NULL,
    "referredByCode" text,
    "referralStatus" text DEFAULT 'PENDING'::text NOT NULL,
    "referralCampaignId" integer,
    "signupCampaignId" integer,
    "signupStatus" text DEFAULT 'PENDING'::text NOT NULL,
    "brandId" integer DEFAULT 1 NOT NULL
);
COMMENT ON TABLE crm."customerReferral" IS 'This table maintains a record of all the customer and brand''s referral codes.';
COMMENT ON COLUMN crm."customerReferral".id IS 'Auto-generated id for the row.';
COMMENT ON COLUMN crm."customerReferral"."keycloakId" IS 'This is the unique id of customer given by keycloak.';
COMMENT ON COLUMN crm."customerReferral"."referralCode" IS 'This is auto generated UUID code created for each customer to share with others for referral.';
COMMENT ON COLUMN crm."customerReferral"."referredByCode" IS 'This is the referral code that was used by the customer for signing up';
COMMENT ON COLUMN crm."customerReferral"."referralStatus" IS 'This denotes the status if the customer who referred was awarded something according to the referral campaign id.';
COMMENT ON COLUMN crm."customerReferral"."referralCampaignId" IS 'The id of the campaign to be used to award the referrer.';
COMMENT ON COLUMN crm."customerReferral"."signupCampaignId" IS 'The id of the campaign to be used to reward this customer who signed up.';
COMMENT ON COLUMN crm."customerReferral"."signupStatus" IS 'This denotes the status if the signed up customer was awarded something according to the  signup campaign id.';
COMMENT ON COLUMN crm."customerReferral"."brandId" IS 'This is the brandId from the brand table.';
CREATE SEQUENCE crm."customerReferral_id_seq"
    START WITH 1000
    INCREMENT BY 1
    MINVALUE 1000
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE crm."customerReferral_id_seq" OWNED BY crm."customerReferral".id;
CREATE SEQUENCE crm.customer_id_seq
    START WITH 1000
    INCREMENT BY 1
    MINVALUE 1000
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE crm.customer_id_seq OWNED BY crm.customer.id;
CREATE TABLE crm."loyaltyPoint" (
    id integer DEFAULT public.defaultid('crm'::text, 'loyaltyPoint'::text, 'id'::text) NOT NULL,
    "keycloakId" text NOT NULL,
    points integer DEFAULT 0 NOT NULL,
    "isActive" boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    "brandId" integer DEFAULT 1 NOT NULL
);
COMMENT ON TABLE crm."loyaltyPoint" IS 'This table maintains record of all the loyalty point references of all customers across all brands.';
COMMENT ON COLUMN crm."loyaltyPoint"."keycloakId" IS 'Customer keycloak Id referencing the customer for this row.';
COMMENT ON COLUMN crm."loyaltyPoint".points IS 'Available loyalty points for this customer across the referenced brand in the row.';
COMMENT ON COLUMN crm."loyaltyPoint"."isActive" IS 'If loyalty points for this customer is active.';
COMMENT ON COLUMN crm."loyaltyPoint"."brandId" IS 'Id of the brand for which this loyalty point is created and maintained.';
CREATE TABLE crm."loyaltyPointTransaction" (
    id integer DEFAULT public.defaultid('crm'::text, 'loyaltyPointTransaction'::text, 'id'::text) NOT NULL,
    "loyaltyPointId" integer NOT NULL,
    points integer NOT NULL,
    "orderCartId" integer,
    type text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    "amountRedeemed" numeric,
    "customerReferralId" integer
);
COMMENT ON TABLE crm."loyaltyPointTransaction" IS 'This table lists all the loyalty point transactions taking place.';
CREATE SEQUENCE crm."loyaltyPointTransaction_id_seq"
    START WITH 1000
    INCREMENT BY 1
    MINVALUE 1000
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE crm."loyaltyPointTransaction_id_seq" OWNED BY crm."loyaltyPointTransaction".id;
CREATE SEQUENCE crm."loyaltyPoint_id_seq"
    START WITH 1000
    INCREMENT BY 1
    MINVALUE 1000
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE crm."loyaltyPoint_id_seq" OWNED BY crm."loyaltyPoint".id;
CREATE TABLE crm.reward (
    id integer DEFAULT public.defaultid('crm'::text, 'reward'::text, 'id'::text) NOT NULL,
    type text NOT NULL,
    "couponId" integer,
    "conditionId" integer,
    "position" numeric ,
    "campaignId" integer,
    "rewardValue" jsonb
);
CREATE TABLE crm."rewardHistory" (
    id integer DEFAULT public.defaultid('crm'::text, 'rewardHistory'::text, 'id'::text) NOT NULL,
    "rewardId" integer NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    "couponId" integer,
    "campaignId" integer,
    "keycloakId" text NOT NULL,
    "orderCartId" integer,
    "orderId" integer,
    discount numeric,
    "loyaltyPointTransactionId" integer,
    "loyaltyPoints" integer,
    "walletAmount" numeric,
    "walletTransactionId" integer,
    "brandId" integer DEFAULT 1 NOT NULL
);
CREATE SEQUENCE crm."rewardHistory_id_seq"
    START WITH 1000
    INCREMENT BY 1
    MINVALUE 1000
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE crm."rewardHistory_id_seq" OWNED BY crm."rewardHistory".id;
CREATE TABLE crm."rewardType" (
    id integer DEFAULT public.defaultid('crm'::text, 'rewardType'::text, 'id'::text) NOT NULL,
    value text NOT NULL,
    "useForCoupon" boolean NOT NULL,
    handler text NOT NULL
);
CREATE TABLE crm."rewardType_campaignType" (
    "rewardTypeId" integer NOT NULL,
    "campaignTypeId" integer NOT NULL
);
CREATE VIEW crm.view_brand_customer AS
 SELECT brand_customer.id,
    brand_customer."keycloakId",
    brand_customer."brandId",
    brand_customer.created_at,
    brand_customer.updated_at,
    brand_customer."isSubscriber",
    brand_customer."subscriptionId",
    brand_customer."subscriptionAddressId",
    brand_customer."subscriptionPaymentMethodId",
    brand_customer."isAutoSelectOptOut",
    brand_customer."isSubscriberTimeStamp",
    brand_customer."subscriptionServingId",
    brand_customer."subscriptionItemCountId",
    brand_customer."subscriptionTitleId",
    ( SELECT subscription."customerSubscriptionReport"(brand_customer.id, 'All'::text) AS "customerSubscriptionReport") AS "allSubscriptionOccurences",
    ( SELECT subscription."customerSubscriptionReport"(brand_customer.id, 'Skipped'::text) AS "customerSubscriptionReport") AS "skippedSubscriptionOccurences"
   FROM crm.brand_customer;
CREATE TABLE crm.wallet (
    id integer DEFAULT public.defaultid('crm'::text, 'wallet'::text, 'id'::text) NOT NULL,
    "keycloakId" text,
    amount numeric DEFAULT 0 NOT NULL,
    "isActive" boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    "brandId" integer DEFAULT 1 NOT NULL
);
CREATE TABLE crm."walletTransaction" (
    id integer DEFAULT public.defaultid('crm'::text, 'walletTransaction'::text, 'id'::text) NOT NULL,
    "walletId" integer NOT NULL,
    amount numeric NOT NULL,
    type text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    "orderCartId" integer,
    "customerReferralId" integer
);
CREATE SEQUENCE crm."walletTransaction_id_seq"
    START WITH 1000
    INCREMENT BY 1
    MINVALUE 1000
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE crm."walletTransaction_id_seq" OWNED BY crm."walletTransaction".id;
CREATE SEQUENCE crm.wallet_id_seq
    START WITH 1000
    INCREMENT BY 1
    MINVALUE 1000
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE crm.wallet_id_seq OWNED BY crm.wallet.id;
CREATE VIEW datahub_schema.columns AS
 SELECT columns.table_catalog,
    columns.table_schema,
    columns.table_name,
    columns.column_name,
    columns.ordinal_position,
    columns.column_default,
    columns.is_nullable,
    columns.data_type,
    columns.character_maximum_length,
    columns.character_octet_length,
    columns.numeric_precision,
    columns.numeric_precision_radix,
    columns.numeric_scale,
    columns.datetime_precision,
    columns.interval_type,
    columns.interval_precision,
    columns.character_set_catalog,
    columns.character_set_schema,
    columns.character_set_name,
    columns.collation_catalog,
    columns.collation_schema,
    columns.collation_name,
    columns.domain_catalog,
    columns.domain_schema,
    columns.domain_name,
    columns.udt_catalog,
    columns.udt_schema,
    columns.udt_name,
    columns.scope_catalog,
    columns.scope_schema,
    columns.scope_name,
    columns.maximum_cardinality,
    columns.dtd_identifier,
    columns.is_self_referencing,
    columns.is_identity,
    columns.identity_generation,
    columns.identity_start,
    columns.identity_increment,
    columns.identity_maximum,
    columns.identity_minimum,
    columns.identity_cycle,
    columns.is_generated,
    columns.generation_expression,
    columns.is_updatable,
    ( SELECT concat('"', columns.table_schema, '"."', columns.table_name, '"."', columns.column_name, '"') AS concat) AS column_reference,
    ( SELECT concat('"', columns.table_schema, '"."', columns.table_name, '"') AS concat) AS table_reference,
    ( SELECT concat('"', columns.table_schema, '"') AS concat) AS schema_reference
   FROM information_schema.columns
  WHERE ((columns.table_schema)::name <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name]));
CREATE VIEW datahub_schema.columns_privileges AS
 SELECT columns.table_catalog,
    columns.table_schema,
    columns.table_name,
    columns.column_name,
    columns.ordinal_position,
    columns.column_default,
    columns.is_nullable,
    columns.data_type,
    columns.character_maximum_length,
    columns.character_octet_length,
    columns.numeric_precision,
    columns.numeric_precision_radix,
    columns.numeric_scale,
    columns.datetime_precision,
    columns.interval_type,
    columns.interval_precision,
    columns.character_set_catalog,
    columns.character_set_schema,
    columns.character_set_name,
    columns.collation_catalog,
    columns.collation_schema,
    columns.collation_name,
    columns.domain_catalog,
    columns.domain_schema,
    columns.domain_name,
    columns.udt_catalog,
    columns.udt_schema,
    columns.udt_name,
    columns.scope_catalog,
    columns.scope_schema,
    columns.scope_name,
    columns.maximum_cardinality,
    columns.dtd_identifier,
    columns.is_self_referencing,
    columns.is_identity,
    columns.identity_generation,
    columns.identity_start,
    columns.identity_increment,
    columns.identity_maximum,
    columns.identity_minimum,
    columns.identity_cycle,
    columns.is_generated,
    columns.generation_expression,
    columns.is_updatable,
    ( SELECT concat('"', columns.table_schema, '"."', columns.table_name, '"."', columns.column_name, '"') AS concat) AS column_reference,
    ( SELECT concat('"', columns.table_schema, '"."', columns.table_name, '"') AS concat) AS table_reference,
    ( SELECT concat('"', columns.table_schema, '"') AS concat) AS schema_reference
   FROM information_schema.columns
  WHERE ((columns.table_schema)::name <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name]));
CREATE VIEW datahub_schema.constraint_column_usage AS
 SELECT columns.table_catalog,
    columns.table_schema,
    columns.table_name,
    columns.column_name,
    columns.ordinal_position,
    columns.column_default,
    columns.is_nullable,
    columns.data_type,
    columns.character_maximum_length,
    columns.character_octet_length,
    columns.numeric_precision,
    columns.numeric_precision_radix,
    columns.numeric_scale,
    columns.datetime_precision,
    columns.interval_type,
    columns.interval_precision,
    columns.character_set_catalog,
    columns.character_set_schema,
    columns.character_set_name,
    columns.collation_catalog,
    columns.collation_schema,
    columns.collation_name,
    columns.domain_catalog,
    columns.domain_schema,
    columns.domain_name,
    columns.udt_catalog,
    columns.udt_schema,
    columns.udt_name,
    columns.scope_catalog,
    columns.scope_schema,
    columns.scope_name,
    columns.maximum_cardinality,
    columns.dtd_identifier,
    columns.is_self_referencing,
    columns.is_identity,
    columns.identity_generation,
    columns.identity_start,
    columns.identity_increment,
    columns.identity_maximum,
    columns.identity_minimum,
    columns.identity_cycle,
    columns.is_generated,
    columns.generation_expression,
    columns.is_updatable,
    ( SELECT concat('"', columns.table_schema, '"."', columns.table_name, '"."', columns.column_name, '"') AS concat) AS column_reference,
    ( SELECT concat('"', columns.table_schema, '"."', columns.table_name, '"') AS concat) AS table_reference,
    ( SELECT concat('"', columns.table_schema, '"') AS concat) AS schema_reference
   FROM information_schema.columns
  WHERE ((columns.table_schema)::name <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name]));
CREATE VIEW datahub_schema.constraint_table_usage AS
 SELECT columns.table_catalog,
    columns.table_schema,
    columns.table_name,
    columns.column_name,
    columns.ordinal_position,
    columns.column_default,
    columns.is_nullable,
    columns.data_type,
    columns.character_maximum_length,
    columns.character_octet_length,
    columns.numeric_precision,
    columns.numeric_precision_radix,
    columns.numeric_scale,
    columns.datetime_precision,
    columns.interval_type,
    columns.interval_precision,
    columns.character_set_catalog,
    columns.character_set_schema,
    columns.character_set_name,
    columns.collation_catalog,
    columns.collation_schema,
    columns.collation_name,
    columns.domain_catalog,
    columns.domain_schema,
    columns.domain_name,
    columns.udt_catalog,
    columns.udt_schema,
    columns.udt_name,
    columns.scope_catalog,
    columns.scope_schema,
    columns.scope_name,
    columns.maximum_cardinality,
    columns.dtd_identifier,
    columns.is_self_referencing,
    columns.is_identity,
    columns.identity_generation,
    columns.identity_start,
    columns.identity_increment,
    columns.identity_maximum,
    columns.identity_minimum,
    columns.identity_cycle,
    columns.is_generated,
    columns.generation_expression,
    columns.is_updatable,
    ( SELECT concat('"', columns.table_schema, '"."', columns.table_name, '"') AS concat) AS table_reference,
    ( SELECT concat('"', columns.table_schema, '"') AS concat) AS schema_reference
   FROM information_schema.columns
  WHERE ((columns.table_schema)::name <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name]));
CREATE VIEW datahub_schema.event_invocation_logs AS
 SELECT event_invocation_logs.id,
    event_invocation_logs.event_id,
    event_invocation_logs.status,
    event_invocation_logs.request,
    event_invocation_logs.response,
    event_invocation_logs.created_at
   FROM hdb_catalog.event_invocation_logs;
CREATE VIEW datahub_schema.event_log AS
 SELECT event_log.id,
    event_log.schema_name,
    event_log.table_name,
    event_log.trigger_name,
    event_log.payload,
    event_log.delivered,
    event_log.error,
    event_log.tries,
    event_log.created_at,
    event_log.locked,
    event_log.next_retry_at,
    event_log.archived
   FROM hdb_catalog.event_log;
CREATE VIEW datahub_schema.event_triggers AS
 SELECT event_triggers.name,
    event_triggers.type,
    event_triggers.schema_name,
    event_triggers.table_name,
    event_triggers.configuration,
    event_triggers.comment
   FROM hdb_catalog.event_triggers;
CREATE VIEW datahub_schema.hdb_action AS
 SELECT hdb_action.action_name,
    hdb_action.action_defn,
    hdb_action.comment,
    hdb_action.is_system_defined
   FROM hdb_catalog.hdb_action;
CREATE VIEW datahub_schema.hdb_action_log AS
 SELECT hdb_action_log.id,
    hdb_action_log.action_name,
    hdb_action_log.input_payload,
    hdb_action_log.request_headers,
    hdb_action_log.session_variables,
    hdb_action_log.response_payload,
    hdb_action_log.errors,
    hdb_action_log.created_at,
    hdb_action_log.response_received_at,
    hdb_action_log.status
   FROM hdb_catalog.hdb_action_log;
CREATE VIEW datahub_schema.hdb_action_permission AS
 SELECT hdb_action_permission.action_name,
    hdb_action_permission.role_name,
    hdb_action_permission.definition,
    hdb_action_permission.comment
   FROM hdb_catalog.hdb_action_permission;
CREATE VIEW datahub_schema.hdb_computed_field AS
 SELECT hdb_computed_field.table_schema,
    hdb_computed_field.table_name,
    hdb_computed_field.computed_field_name,
    hdb_computed_field.definition,
    hdb_computed_field.comment
   FROM hdb_catalog.hdb_computed_field;
CREATE VIEW datahub_schema.hdb_cron_event_invocation_logs AS
 SELECT hdb_cron_event_invocation_logs.id,
    hdb_cron_event_invocation_logs.event_id,
    hdb_cron_event_invocation_logs.status,
    hdb_cron_event_invocation_logs.request,
    hdb_cron_event_invocation_logs.response,
    hdb_cron_event_invocation_logs.created_at
   FROM hdb_catalog.hdb_cron_event_invocation_logs;
CREATE VIEW datahub_schema.hdb_cron_events AS
 SELECT hdb_cron_events.id,
    hdb_cron_events.trigger_name,
    hdb_cron_events.scheduled_time,
    hdb_cron_events.status,
    hdb_cron_events.tries,
    hdb_cron_events.created_at,
    hdb_cron_events.next_retry_at
   FROM hdb_catalog.hdb_cron_events;
CREATE VIEW datahub_schema.hdb_cron_triggers AS
 SELECT hdb_cron_triggers.name,
    hdb_cron_triggers.webhook_conf,
    hdb_cron_triggers.cron_schedule,
    hdb_cron_triggers.payload,
    hdb_cron_triggers.retry_conf,
    hdb_cron_triggers.header_conf,
    hdb_cron_triggers.include_in_metadata,
    hdb_cron_triggers.comment
   FROM hdb_catalog.hdb_cron_triggers;
CREATE VIEW datahub_schema.hdb_custom_types AS
 SELECT hdb_custom_types.custom_types
   FROM hdb_catalog.hdb_custom_types;
CREATE VIEW datahub_schema.hdb_function AS
 SELECT hdb_function.function_schema,
    hdb_function.function_name,
    hdb_function.configuration,
    hdb_function.is_system_defined
   FROM hdb_catalog.hdb_function;
CREATE VIEW datahub_schema.hdb_permission AS
 SELECT hdb_permission.table_schema,
    hdb_permission.table_name,
    hdb_permission.role_name,
    hdb_permission.perm_type,
    hdb_permission.perm_def,
    hdb_permission.comment,
    hdb_permission.is_system_defined
   FROM hdb_catalog.hdb_permission;
CREATE VIEW datahub_schema.hdb_relationship AS
 SELECT hdb_relationship.table_schema,
    hdb_relationship.table_name,
    hdb_relationship.rel_name,
    hdb_relationship.rel_type,
    hdb_relationship.rel_def,
    hdb_relationship.comment,
    hdb_relationship.is_system_defined
   FROM hdb_catalog.hdb_relationship;
CREATE VIEW datahub_schema.hdb_remote_relationship AS
 SELECT hdb_remote_relationship.remote_relationship_name,
    hdb_remote_relationship.table_schema,
    hdb_remote_relationship.table_name,
    hdb_remote_relationship.definition
   FROM hdb_catalog.hdb_remote_relationship;
CREATE VIEW datahub_schema.hdb_scheduled_event_invocation_logs AS
 SELECT hdb_scheduled_event_invocation_logs.id,
    hdb_scheduled_event_invocation_logs.event_id,
    hdb_scheduled_event_invocation_logs.status,
    hdb_scheduled_event_invocation_logs.request,
    hdb_scheduled_event_invocation_logs.response,
    hdb_scheduled_event_invocation_logs.created_at
   FROM hdb_catalog.hdb_scheduled_event_invocation_logs;
CREATE VIEW datahub_schema.hdb_scheduled_events AS
 SELECT hdb_scheduled_events.id,
    hdb_scheduled_events.webhook_conf,
    hdb_scheduled_events.scheduled_time,
    hdb_scheduled_events.retry_conf,
    hdb_scheduled_events.payload,
    hdb_scheduled_events.header_conf,
    hdb_scheduled_events.status,
    hdb_scheduled_events.tries,
    hdb_scheduled_events.created_at,
    hdb_scheduled_events.next_retry_at,
    hdb_scheduled_events.comment
   FROM hdb_catalog.hdb_scheduled_events;
CREATE VIEW datahub_schema.hdb_table AS
 SELECT hdb_table.table_schema,
    hdb_table.table_name,
    hdb_table.configuration,
    hdb_table.is_system_defined,
    hdb_table.is_enum,
    ( SELECT concat('"', hdb_table.table_schema, '"."', hdb_table.table_name, '"') AS concat) AS table_reference,
    ( SELECT concat('"', hdb_table.table_schema, '"') AS concat) AS schema_reference
   FROM hdb_catalog.hdb_table;
CREATE VIEW datahub_schema.key_column_usage AS
 SELECT columns.table_catalog,
    columns.table_schema,
    columns.table_name,
    columns.column_name,
    columns.ordinal_position,
    columns.column_default,
    columns.is_nullable,
    columns.data_type,
    columns.character_maximum_length,
    columns.character_octet_length,
    columns.numeric_precision,
    columns.numeric_precision_radix,
    columns.numeric_scale,
    columns.datetime_precision,
    columns.interval_type,
    columns.interval_precision,
    columns.character_set_catalog,
    columns.character_set_schema,
    columns.character_set_name,
    columns.collation_catalog,
    columns.collation_schema,
    columns.collation_name,
    columns.domain_catalog,
    columns.domain_schema,
    columns.domain_name,
    columns.udt_catalog,
    columns.udt_schema,
    columns.udt_name,
    columns.scope_catalog,
    columns.scope_schema,
    columns.scope_name,
    columns.maximum_cardinality,
    columns.dtd_identifier,
    columns.is_self_referencing,
    columns.is_identity,
    columns.identity_generation,
    columns.identity_start,
    columns.identity_increment,
    columns.identity_maximum,
    columns.identity_minimum,
    columns.identity_cycle,
    columns.is_generated,
    columns.generation_expression,
    columns.is_updatable,
    ( SELECT concat('"', columns.table_schema, '"."', columns.table_name, '"."', columns.column_name, '"') AS concat) AS column_reference,
    ( SELECT concat('"', columns.table_schema, '"."', columns.table_name, '"') AS concat) AS table_reference,
    ( SELECT concat('"', columns.table_schema, '"') AS concat) AS schema_reference
   FROM information_schema.columns
  WHERE ((columns.table_schema)::name <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name]));
CREATE VIEW datahub_schema.referential_constraints AS
 SELECT referential_constraints.constraint_catalog,
    referential_constraints.constraint_schema,
    referential_constraints.constraint_name,
    referential_constraints.unique_constraint_catalog,
    referential_constraints.unique_constraint_schema,
    referential_constraints.unique_constraint_name,
    referential_constraints.match_option,
    referential_constraints.update_rule,
    referential_constraints.delete_rule,
    ( SELECT concat('"', referential_constraints.constraint_schema, '"."', referential_constraints.constraint_name, '"') AS concat) AS constraint_reference,
    ( SELECT concat('"', referential_constraints.constraint_schema, '"') AS concat) AS constraint_schema_reference
   FROM information_schema.referential_constraints
  WHERE ((referential_constraints.unique_constraint_schema)::name <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name]));
CREATE VIEW datahub_schema.remote_schemas AS
 SELECT remote_schemas.id,
    remote_schemas.name,
    remote_schemas.definition,
    remote_schemas.comment
   FROM hdb_catalog.remote_schemas;
CREATE VIEW datahub_schema.role_column_grant AS
 SELECT columns.table_catalog,
    columns.table_schema,
    columns.table_name,
    columns.column_name,
    columns.ordinal_position,
    columns.column_default,
    columns.is_nullable,
    columns.data_type,
    columns.character_maximum_length,
    columns.character_octet_length,
    columns.numeric_precision,
    columns.numeric_precision_radix,
    columns.numeric_scale,
    columns.datetime_precision,
    columns.interval_type,
    columns.interval_precision,
    columns.character_set_catalog,
    columns.character_set_schema,
    columns.character_set_name,
    columns.collation_catalog,
    columns.collation_schema,
    columns.collation_name,
    columns.domain_catalog,
    columns.domain_schema,
    columns.domain_name,
    columns.udt_catalog,
    columns.udt_schema,
    columns.udt_name,
    columns.scope_catalog,
    columns.scope_schema,
    columns.scope_name,
    columns.maximum_cardinality,
    columns.dtd_identifier,
    columns.is_self_referencing,
    columns.is_identity,
    columns.identity_generation,
    columns.identity_start,
    columns.identity_increment,
    columns.identity_maximum,
    columns.identity_minimum,
    columns.identity_cycle,
    columns.is_generated,
    columns.generation_expression,
    columns.is_updatable,
    ( SELECT concat('"', columns.table_schema, '"."', columns.table_name, '"."', columns.column_name, '"') AS concat) AS column_reference,
    ( SELECT concat('"', columns.table_schema, '"."', columns.table_name, '"') AS concat) AS table_reference,
    ( SELECT concat('"', columns.table_schema, '"') AS concat) AS schema_reference
   FROM information_schema.columns
  WHERE ((columns.table_schema)::name <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name]));
CREATE VIEW datahub_schema.routines AS
 SELECT routines.specific_catalog,
    routines.specific_schema,
    routines.specific_name,
    routines.routine_catalog,
    routines.routine_schema,
    routines.routine_name,
    routines.routine_type,
    routines.module_catalog,
    routines.module_schema,
    routines.module_name,
    routines.udt_catalog,
    routines.udt_schema,
    routines.udt_name,
    routines.data_type,
    routines.character_maximum_length,
    routines.character_octet_length,
    routines.character_set_catalog,
    routines.character_set_schema,
    routines.character_set_name,
    routines.collation_catalog,
    routines.collation_schema,
    routines.collation_name,
    routines.numeric_precision,
    routines.numeric_precision_radix,
    routines.numeric_scale,
    routines.datetime_precision,
    routines.interval_type,
    routines.interval_precision,
    routines.type_udt_catalog,
    routines.type_udt_schema,
    routines.type_udt_name,
    routines.scope_catalog,
    routines.scope_schema,
    routines.scope_name,
    routines.maximum_cardinality,
    routines.dtd_identifier,
    routines.routine_body,
    routines.routine_definition,
    routines.external_name,
    routines.external_language,
    routines.parameter_style,
    routines.is_deterministic,
    routines.sql_data_access,
    routines.is_null_call,
    routines.sql_path,
    routines.schema_level_routine,
    routines.max_dynamic_result_sets,
    routines.is_user_defined_cast,
    routines.is_implicitly_invocable,
    routines.security_type,
    routines.to_sql_specific_catalog,
    routines.to_sql_specific_schema,
    routines.to_sql_specific_name,
    routines.as_locator,
    routines.created,
    routines.last_altered,
    routines.new_savepoint_level,
    routines.is_udt_dependent,
    routines.result_cast_from_data_type,
    routines.result_cast_as_locator,
    routines.result_cast_char_max_length,
    routines.result_cast_char_octet_length,
    routines.result_cast_char_set_catalog,
    routines.result_cast_char_set_schema,
    routines.result_cast_char_set_name,
    routines.result_cast_collation_catalog,
    routines.result_cast_collation_schema,
    routines.result_cast_collation_name,
    routines.result_cast_numeric_precision,
    routines.result_cast_numeric_precision_radix,
    routines.result_cast_numeric_scale,
    routines.result_cast_datetime_precision,
    routines.result_cast_interval_type,
    routines.result_cast_interval_precision,
    routines.result_cast_type_udt_catalog,
    routines.result_cast_type_udt_schema,
    routines.result_cast_type_udt_name,
    routines.result_cast_scope_catalog,
    routines.result_cast_scope_schema,
    routines.result_cast_scope_name,
    routines.result_cast_maximum_cardinality,
    routines.result_cast_dtd_identifier,
    ( SELECT concat('"', routines.routine_schema, '"."', routines.routine_name, '"') AS concat) AS routine_reference,
    ( SELECT concat('"', routines.routine_schema, '"') AS concat) AS routine_schema_reference
   FROM information_schema.routines
  WHERE ((routines.specific_schema)::name <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name]));
CREATE VIEW datahub_schema.schemata AS
 SELECT schemata.catalog_name,
    schemata.schema_name,
    schemata.schema_owner,
    schemata.default_character_set_catalog,
    schemata.default_character_set_schema,
    schemata.default_character_set_name,
    schemata.sql_path,
    ( SELECT concat('"', schemata.schema_name, '"') AS concat) AS schema_reference
   FROM information_schema.schemata;
CREATE VIEW datahub_schema.sequences AS
 SELECT sequences.sequence_catalog,
    sequences.sequence_schema,
    sequences.sequence_name,
    sequences.data_type,
    sequences.numeric_precision,
    sequences.numeric_precision_radix,
    sequences.numeric_scale,
    sequences.start_value,
    sequences.minimum_value,
    sequences.maximum_value,
    sequences.increment,
    sequences.cycle_option,
    sequences.sequence_schema AS schema_reference
   FROM information_schema.sequences
  WHERE ((sequences.sequence_schema)::name <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name]));
CREATE VIEW datahub_schema.table_constraints AS
 SELECT table_constraints.constraint_catalog,
    table_constraints.constraint_schema,
    table_constraints.constraint_name,
    table_constraints.table_catalog,
    table_constraints.table_schema,
    table_constraints.table_name,
    table_constraints.constraint_type,
    table_constraints.is_deferrable,
    table_constraints.initially_deferred,
    table_constraints.enforced,
    ( SELECT concat('"', table_constraints.table_schema, '"."', table_constraints.table_name, '"') AS concat) AS table_reference,
    ( SELECT concat('"', table_constraints.table_schema, '"') AS concat) AS schema_reference
   FROM information_schema.table_constraints
  WHERE ((table_constraints.constraint_schema)::name <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name]));
CREATE VIEW datahub_schema.table_privileges AS
 SELECT table_privileges.grantor,
    table_privileges.grantee,
    table_privileges.table_catalog,
    table_privileges.table_schema,
    table_privileges.table_name,
    table_privileges.privilege_type,
    table_privileges.is_grantable,
    table_privileges.with_hierarchy,
    ( SELECT concat('"', table_privileges.table_schema, '"."', table_privileges.table_name, '"') AS concat) AS table_reference,
    ( SELECT concat('"', table_privileges.table_schema, '"') AS concat) AS schema_reference
   FROM information_schema.table_privileges
  WHERE ((table_privileges.table_schema)::name <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name]));
CREATE VIEW datahub_schema.tables AS
 SELECT tables.table_catalog,
    tables.table_schema,
    tables.table_name,
    tables.table_type,
    tables.self_referencing_column_name,
    tables.reference_generation,
    tables.user_defined_type_catalog,
    tables.user_defined_type_schema,
    tables.user_defined_type_name,
    tables.is_insertable_into,
    tables.is_typed,
    tables.commit_action,
    ( SELECT concat('"', tables.table_schema, '"."', tables.table_name, '"') AS concat) AS table_reference,
    ( SELECT concat('"', tables.table_schema, '"') AS concat) AS schema_reference
   FROM information_schema.tables
  WHERE ((tables.table_schema)::name <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name]));
CREATE VIEW datahub_schema.triggered_update_column AS
 SELECT triggers.trigger_catalog,
    triggers.trigger_schema,
    triggers.trigger_name,
    triggers.event_manipulation,
    triggers.event_object_catalog,
    triggers.event_object_schema,
    triggers.event_object_table,
    triggers.action_order,
    triggers.action_condition,
    triggers.action_statement,
    triggers.action_orientation,
    triggers.action_timing,
    triggers.action_reference_old_table,
    triggers.action_reference_new_table,
    triggers.action_reference_old_row,
    triggers.action_reference_new_row,
    triggers.created,
    ( SELECT concat('"', triggers.trigger_schema, '"."', triggers.trigger_name, '"') AS concat) AS trigger_reference,
    ( SELECT concat('"', triggers.trigger_schema, '"') AS concat) AS schema_reference
   FROM information_schema.triggers
  WHERE ((triggers.trigger_schema)::name <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name]));
CREATE VIEW datahub_schema.triggers AS
 SELECT triggers.trigger_catalog,
    triggers.trigger_schema,
    triggers.trigger_name,
    triggers.event_manipulation,
    triggers.event_object_catalog,
    triggers.event_object_schema,
    triggers.event_object_table,
    triggers.action_order,
    triggers.action_condition,
    triggers.action_statement,
    triggers.action_orientation,
    triggers.action_timing,
    triggers.action_reference_old_table,
    triggers.action_reference_new_table,
    triggers.action_reference_old_row,
    triggers.action_reference_new_row,
    triggers.created,
    ( SELECT concat('"', triggers.trigger_schema, '"."', triggers.trigger_name, '"') AS concat) AS trigger_reference,
    ( SELECT concat('"', triggers.trigger_schema, '"') AS concat) AS schema_reference
   FROM information_schema.triggers
  WHERE ((triggers.trigger_schema)::name <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name]));
CREATE VIEW datahub_schema.view_column_usage AS
 SELECT view_column_usage.view_catalog,
    view_column_usage.view_schema,
    view_column_usage.view_name,
    view_column_usage.table_catalog,
    view_column_usage.table_schema,
    view_column_usage.table_name,
    view_column_usage.column_name,
    ( SELECT concat('"', view_column_usage.view_schema, '"."', view_column_usage.view_name, '"') AS concat) AS view_reference,
    ( SELECT concat('"', view_column_usage.table_schema, '"."', view_column_usage.table_name, '"') AS concat) AS table_reference,
    ( SELECT concat('"', view_column_usage.view_schema, '"') AS concat) AS view_schema_reference,
    ( SELECT concat('"', view_column_usage.table_schema, '"') AS concat) AS table_schema_reference
   FROM information_schema.view_column_usage
  WHERE ((view_column_usage.view_schema)::name <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name]));
CREATE VIEW datahub_schema.view_routine_usage AS
 SELECT view_routine_usage.table_catalog,
    view_routine_usage.table_schema,
    view_routine_usage.table_name,
    view_routine_usage.specific_catalog,
    view_routine_usage.specific_schema,
    view_routine_usage.specific_name,
    ( SELECT concat('"', view_routine_usage.table_schema, '"."', view_routine_usage.table_name, '"') AS concat) AS table_reference,
    ( SELECT concat('"', view_routine_usage.table_schema, '"') AS concat) AS table_schema_reference
   FROM information_schema.view_routine_usage
  WHERE ((view_routine_usage.table_schema)::name <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name]));
CREATE VIEW datahub_schema.view_table_usage AS
 SELECT view_table_usage.view_catalog,
    view_table_usage.view_schema,
    view_table_usage.view_name,
    view_table_usage.table_catalog,
    view_table_usage.table_schema,
    view_table_usage.table_name,
    ( SELECT concat('"', view_table_usage.view_schema, '"."', view_table_usage.view_name, '"') AS concat) AS view_reference,
    ( SELECT concat('"', view_table_usage.table_schema, '"."', view_table_usage.table_name, '"') AS concat) AS table_reference,
    ( SELECT concat('"', view_table_usage.view_schema, '"') AS concat) AS view_schema_reference,
    ( SELECT concat('"', view_table_usage.table_schema, '"') AS concat) AS table_schema_reference
   FROM information_schema.view_table_usage
  WHERE ((view_table_usage.table_schema)::name <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name]));
CREATE VIEW datahub_schema.views AS
 SELECT views.table_catalog,
    views.table_schema,
    views.table_name,
    views.view_definition,
    views.check_option,
    views.is_updatable,
    views.is_insertable_into,
    views.is_trigger_updatable,
    views.is_trigger_deletable,
    views.is_trigger_insertable_into,
    ( SELECT concat('"', views.table_schema, '"."', views.table_name, '"') AS concat) AS view_reference,
    ( SELECT concat('"', views.table_schema, '"') AS concat) AS schema_reference
   FROM information_schema.views
  WHERE ((views.table_schema)::name <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name]));
CREATE TABLE "deviceHub".computer (
    "printNodeId" integer NOT NULL,
    name text,
    inet text,
    inet6 text,
    hostname text,
    jre text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    state text,
    version text
);
CREATE TABLE "deviceHub".config (
    id integer DEFAULT public.defaultid('deviceHub'::text, 'config'::text, 'id'::text) NOT NULL,
    name text NOT NULL,
    value jsonb NOT NULL
);
CREATE TABLE "deviceHub"."labelTemplate" (
    id integer DEFAULT public.defaultid('deviceHub'::text, 'labelTemplate'::text, 'id'::text) NOT NULL,
    name text NOT NULL
);
CREATE TABLE "deviceHub".printer (
    "printNodeId" integer NOT NULL,
    "computerId" integer NOT NULL,
    name text NOT NULL,
    description text,
    state text NOT NULL,
    bins jsonb,
    "collate" boolean,
    copies integer,
    color boolean,
    dpis jsonb,
    extent jsonb,
    medias jsonb,
    nup jsonb,
    papers jsonb,
    printrate jsonb,
    supports_custom_paper_size boolean,
    duplex boolean,
    "printerType" text
);
CREATE TABLE "deviceHub"."printerType" (
    type text NOT NULL
);
CREATE TABLE "deviceHub".scale (
    "deviceName" text NOT NULL,
    "deviceNum" integer NOT NULL,
    "computerId" integer NOT NULL,
    vendor text,
    "vendorId" integer,
    "productId" integer,
    port text,
    count integer,
    measurement jsonb,
    "ntpOffset" integer,
    "ageOfData" integer,
    "stationId" integer,
    active boolean DEFAULT true,
    id integer DEFAULT public.defaultid('deviceHub'::text, 'scale'::text, 'id'::text) NOT NULL
);
CREATE TABLE editor.block (
    id integer DEFAULT public.defaultid('editor'::text, 'block'::text, 'id'::text) NOT NULL,
    name text NOT NULL,
    path text NOT NULL,
    assets jsonb,
    "fileId" integer NOT NULL,
    category text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);
CREATE TABLE editor."cssFileLinks" (
    "guiFileId" integer NOT NULL,
    "cssFileId" integer NOT NULL,
    "position" bigint,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    id integer DEFAULT public.defaultid('editor'::text, 'cssFileLinks'::text, 'id'::text) NOT NULL
);
CREATE TABLE editor.file (
    id integer DEFAULT public.defaultid('editor'::text, 'file'::text, 'id'::text) NOT NULL,
    path text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    "fileType" text,
    commits jsonb,
    "lastSaved" timestamp with time zone,
    "fileName" text,
    "isTemplate" boolean,
    "isBlock" boolean
);
CREATE TABLE editor."jsFileLinks" (
    "guiFileId" integer NOT NULL,
    "jsFileId" integer NOT NULL,
    "position" integer,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    id integer DEFAULT public.defaultid('editor'::text, 'jsFileLinks'::text, 'id'::text) NOT NULL
);
CREATE TABLE editor."linkedFiles" (
    id integer NOT NULL,
    records jsonb
);
CREATE TABLE editor.template (
    id integer DEFAULT public.defaultid('editor'::text, 'template'::text, 'id'::text) NOT NULL,
    name text NOT NULL,
    route text NOT NULL,
    type text,
    thumbnail text
);
CREATE TABLE fulfilment.brand_recurrence (
    "brandId" integer NOT NULL,
    "recurrenceId" integer NOT NULL,
    "isActive" boolean DEFAULT true NOT NULL
);
CREATE TABLE fulfilment.charge (
    id integer DEFAULT public.defaultid('fulfilment'::text, 'charge'::text, 'id'::text) NOT NULL,
    "orderValueFrom" numeric NOT NULL,
    "orderValueUpto" numeric NOT NULL,
    charge numeric NOT NULL,
    "mileRangeId" integer,
    "autoDeliverySelection" boolean DEFAULT true NOT NULL
);
CREATE TABLE fulfilment."deliveryPreferenceByCharge" (
    "chargeId" integer NOT NULL,
    "clauseId" integer NOT NULL,
    "isActive" boolean DEFAULT true NOT NULL,
    priority integer NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);
CREATE TABLE fulfilment."deliveryService" (
    id integer DEFAULT public.defaultid('fulfilment'::text, 'deliveryService'::text, 'id'::text) NOT NULL,
    "partnershipId" integer,
    "isThirdParty" boolean DEFAULT true NOT NULL,
    "isActive" boolean DEFAULT false,
    "companyName" text NOT NULL,
    logo text
);
CREATE TABLE fulfilment."fulfillmentType" (
    value text NOT NULL,
    "isActive" boolean DEFAULT true NOT NULL
);
CREATE TABLE fulfilment.recurrence (
    id integer DEFAULT public.defaultid('fulfilment'::text, 'recurrence'::text, 'id'::text) NOT NULL,
    rrule text NOT NULL,
    type text DEFAULT 'PREORDER_DELIVERY'::text NOT NULL,
    "isActive" boolean DEFAULT true NOT NULL,
    psql_rrule jsonb
);
CREATE TABLE imports.import (
    id integer DEFAULT public.defaultid('imports'::text, 'import'::text, 'id'::text) NOT NULL,
    entity text NOT NULL,
    file text NOT NULL,
    "importType" text NOT NULL,
    confirm boolean DEFAULT false NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    status text
);
CREATE TABLE imports."importHistory" (
    id integer DEFAULT public.defaultid('imports'::text, 'importHistory'::text, 'id'::text) NOT NULL,
    "importId" integer,
    "importFrom" text
);
CREATE TABLE ingredient."ingredientProcessing" (
    id integer DEFAULT public.defaultid('ingredient'::text, 'ingredientProcessing'::text, 'id'::text) NOT NULL,
    "processingName" text NOT NULL,
    "ingredientId" integer NOT NULL,
    "nutritionalInfo" jsonb,
    cost jsonb,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    "isArchived" boolean DEFAULT false NOT NULL
);
CREATE VIEW ingredient."ingredientProcessingView" AS
 SELECT "ingredientProcessing".id,
    "ingredientProcessing"."processingName",
    "ingredientProcessing"."ingredientId",
    "ingredientProcessing"."nutritionalInfo",
    "ingredientProcessing".cost,
    "ingredientProcessing".created_at,
    "ingredientProcessing".updated_at,
    "ingredientProcessing"."isArchived",
    concat(( SELECT ingredient.name
           FROM ingredient.ingredient
          WHERE (ingredient.id = "ingredientProcessing"."ingredientId")), ' - ', "ingredientProcessing"."processingName") AS "displayName"
   FROM ingredient."ingredientProcessing";
CREATE TABLE ingredient."ingredientSacahet_recipeHubSachet" (
    "ingredientSachetId" integer NOT NULL,
    "recipeHubSachetId" uuid NOT NULL
);
CREATE VIEW ingredient."ingredientSachetView" AS
 SELECT "ingredientSachet".id,
    "ingredientSachet".quantity,
    "ingredientSachet"."ingredientProcessingId",
    "ingredientSachet"."ingredientId",
    "ingredientSachet"."createdAt",
    "ingredientSachet"."updatedAt",
    "ingredientSachet".tracking,
    "ingredientSachet".unit,
    "ingredientSachet".visibility,
    "ingredientSachet"."liveMOF",
    "ingredientSachet"."isArchived",
    concat(( SELECT "ingredientProcessingView"."displayName"
           FROM ingredient."ingredientProcessingView"
          WHERE ("ingredientProcessingView".id = "ingredientSachet"."ingredientProcessingId")), ' - ', "ingredientSachet".quantity, "ingredientSachet".unit) AS "displayName"
   FROM ingredient."ingredientSachet";
CREATE SEQUENCE ingredient.ingredient_id_seq
    START WITH 1000
    INCREMENT BY 1
    MINVALUE 1000
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE ingredient.ingredient_id_seq OWNED BY ingredient.ingredient.id;
CREATE TABLE ingredient."modeOfFulfillmentEnum" (
    value text NOT NULL,
    description text
);
CREATE TABLE insights.app_module_insight (
    "appTitle" text NOT NULL,
    "moduleTitle" text NOT NULL,
    "insightIdentifier" text NOT NULL
);
CREATE TABLE insights.chart (
    id integer DEFAULT public.defaultid('insights'::text, 'chart'::text, 'id'::text) NOT NULL,
    "layoutType" text DEFAULT 'HERO'::text,
    config jsonb,
    "insightIdentifier" text NOT NULL
);
CREATE TABLE insights.date (
    date date NOT NULL,
    day text
);
CREATE TABLE insights.day (
    "dayName" text NOT NULL,
    "dayNumber" integer
);
CREATE TABLE insights.hour (
    hour integer NOT NULL
);
CREATE TABLE insights.insights (
    query text NOT NULL,
    "availableOptions" jsonb NOT NULL,
    switches jsonb NOT NULL,
    "isActive" boolean DEFAULT false,
    "defaultOptions" jsonb,
    identifier text NOT NULL,
    description text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    filters jsonb,
    config jsonb,
    "schemaVariables" jsonb
);
COMMENT ON COLUMN insights.insights.filters IS 'same as availableOptions, will be used to render individual options like date range in insights.';
CREATE TABLE insights.month (
    number integer NOT NULL,
    name text NOT NULL
);
CREATE TABLE instructions."instructionSet" (
    id integer DEFAULT public.defaultid('instructions'::text, 'instructionSet'::text, 'id'::text) NOT NULL,
    title text,
    "position" integer,
    "simpleRecipeId" integer,
    "productOptionId" integer
);
CREATE TABLE instructions."instructionStep" (
    id integer DEFAULT public.defaultid('instructions'::text, 'instructionStep'::text, 'id'::text) NOT NULL,
    title text,
    description text,
    assets jsonb DEFAULT jsonb_build_object('images', '[]'::jsonb, 'videos', '[]'::jsonb) NOT NULL,
    "position" integer,
    "instructionSetId" integer NOT NULL,
    "isVisible" boolean DEFAULT true NOT NULL
);
CREATE TABLE inventory."bulkItem" (
    id integer DEFAULT public.defaultid('inventory'::text, 'bulkItem'::text, 'id'::text) NOT NULL,
    "processingName" text NOT NULL,
    "supplierItemId" integer NOT NULL,
    labor jsonb,
    "shelfLife" jsonb,
    yield jsonb,
    "nutritionInfo" jsonb,
    sop jsonb,
    allergens jsonb,
    "parLevel" numeric,
    "maxLevel" numeric,
    "onHand" numeric DEFAULT 0 NOT NULL,
    "storageCondition" jsonb,
    "createdAt" timestamp with time zone DEFAULT now(),
    "updatedAt" timestamp with time zone DEFAULT now(),
    "bulkDensity" numeric DEFAULT 1,
    equipments jsonb,
    unit text,
    committed numeric DEFAULT 0 NOT NULL,
    awaiting numeric DEFAULT 0 NOT NULL,
    consumed numeric DEFAULT 0 NOT NULL,
    "isAvailable" boolean DEFAULT true NOT NULL,
    "isArchived" boolean DEFAULT false NOT NULL,
    image jsonb
);
CREATE TABLE inventory."bulkItemHistory" (
    id integer DEFAULT public.defaultid('inventory'::text, 'bulkItemHistory'::text, 'id'::text) NOT NULL,
    "bulkItemId" integer NOT NULL,
    quantity numeric NOT NULL,
    comment jsonb,
    "purchaseOrderItemId" integer,
    "bulkWorkOrderId" integer,
    status text NOT NULL,
    unit text,
    "orderSachetId" integer,
    "sachetWorkOrderId" integer,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);
CREATE VIEW inventory."bulkItemView" AS
 SELECT "bulkItem"."supplierItemId",
    "bulkItem"."processingName",
    ( SELECT "supplierItem".name
           FROM inventory."supplierItem"
          WHERE ("supplierItem".id = "bulkItem"."supplierItemId")) AS "supplierItemName",
    ( SELECT "supplierItem"."supplierId"
           FROM inventory."supplierItem"
          WHERE ("supplierItem".id = "bulkItem"."supplierItemId")) AS "supplierId",
    "bulkItem".id,
    "bulkItem"."bulkDensity"
   FROM inventory."bulkItem";
CREATE TABLE inventory."bulkItem_unitConversion" (
    id integer DEFAULT public.defaultid('inventory'::text, 'bulkItem_unitConversion'::text, 'id'::text) NOT NULL,
    "entityId" integer NOT NULL,
    "unitConversionId" integer NOT NULL
);
CREATE TABLE inventory."bulkWorkOrder" (
    id integer DEFAULT public.defaultid('inventory'::text, 'bulkWorkOrder'::text, 'id'::text) NOT NULL,
    "inputBulkItemId" integer,
    "outputBulkItemId" integer,
    "outputQuantity" numeric DEFAULT 0 NOT NULL,
    "userId" integer,
    "scheduledOn" timestamp with time zone,
    "inputQuantity" numeric,
    status text DEFAULT 'UNPUBLISHED'::text,
    "stationId" integer,
    "inputQuantityUnit" text,
    "supplierItemId" integer,
    "isPublished" boolean DEFAULT false NOT NULL,
    name text,
    "outputYield" numeric
);
CREATE TABLE inventory."packagingHistory" (
    id integer DEFAULT public.defaultid('inventory'::text, 'packagingHistory'::text, 'id'::text) NOT NULL,
    "packagingId" integer NOT NULL,
    quantity numeric NOT NULL,
    "purchaseOrderItemId" integer NOT NULL,
    status text DEFAULT 'PENDING'::text NOT NULL,
    unit text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);
CREATE TABLE inventory."purchaseOrderItem" (
    id integer DEFAULT public.defaultid('inventory'::text, 'purchaseOrderItem'::text, 'id'::text) NOT NULL,
    "bulkItemId" integer,
    "supplierItemId" integer,
    "orderQuantity" numeric DEFAULT 0,
    status text DEFAULT 'UNPUBLISHED'::text NOT NULL,
    details jsonb,
    unit text,
    "supplierId" integer,
    price numeric,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    "packagingId" integer,
    "mandiPurchaseOrderItemId" integer,
    type text DEFAULT 'PACKAGING'::text NOT NULL
);
CREATE TABLE inventory."sachetItem" (
    id integer DEFAULT public.defaultid('inventory'::text, 'sachetItem'::text, 'id'::text) NOT NULL,
    "unitSize" numeric NOT NULL,
    "parLevel" numeric,
    "maxLevel" numeric,
    "onHand" numeric DEFAULT 0 NOT NULL,
    "isAvailable" boolean DEFAULT true NOT NULL,
    "bulkItemId" integer NOT NULL,
    unit text NOT NULL,
    consumed numeric DEFAULT 0 NOT NULL,
    awaiting numeric DEFAULT 0 NOT NULL,
    committed numeric DEFAULT 0 NOT NULL,
    "isArchived" boolean DEFAULT false NOT NULL
);
CREATE TABLE inventory."sachetItemHistory" (
    id integer DEFAULT public.defaultid('inventory'::text, 'sachetItemHistory'::text, 'id'::text) NOT NULL,
    "sachetItemId" integer NOT NULL,
    "sachetWorkOrderId" integer,
    quantity numeric NOT NULL,
    comment jsonb,
    status text NOT NULL,
    "orderSachetId" integer,
    unit text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);
CREATE VIEW inventory."sachetItemView" AS
 SELECT "sachetItem".id,
    "sachetItem"."unitSize",
    "sachetItem"."bulkItemId",
    ( SELECT "bulkItemView"."supplierItemName"
           FROM inventory."bulkItemView"
          WHERE ("bulkItemView".id = "sachetItem"."bulkItemId")) AS "supplierItemName",
    ( SELECT "bulkItemView"."processingName"
           FROM inventory."bulkItemView"
          WHERE ("bulkItemView".id = "sachetItem"."bulkItemId")) AS "processingName",
    ( SELECT "bulkItemView"."supplierId"
           FROM inventory."bulkItemView"
          WHERE ("bulkItemView".id = "sachetItem"."bulkItemId")) AS "supplierId",
    "sachetItem".unit,
    ( SELECT "bulkItem"."bulkDensity"
           FROM inventory."bulkItem"
          WHERE ("bulkItem".id = "sachetItem"."bulkItemId")) AS "bulkDensity"
   FROM inventory."sachetItem";
CREATE TABLE inventory."sachetWorkOrder" (
    id integer DEFAULT public.defaultid('inventory'::text, 'sachetWorkOrder'::text, 'id'::text) NOT NULL,
    "inputBulkItemId" integer,
    "outputSachetItemId" integer,
    "outputQuantity" numeric DEFAULT 0 NOT NULL,
    "inputQuantity" numeric,
    "packagingId" integer,
    label jsonb,
    "stationId" integer,
    "userId" integer,
    "scheduledOn" timestamp with time zone,
    status text DEFAULT 'UNPUBLISHED'::text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    name text,
    "supplierItemId" integer,
    "isPublished" boolean DEFAULT false NOT NULL
);
CREATE TABLE inventory.supplier (
    id integer DEFAULT public.defaultid('inventory'::text, 'supplier'::text, 'id'::text) NOT NULL,
    name text NOT NULL,
    "contactPerson" jsonb,
    address jsonb,
    "shippingTerms" jsonb,
    "paymentTerms" jsonb,
    available boolean DEFAULT true NOT NULL,
    "importId" integer,
    "mandiSupplierId" integer,
    logo jsonb
);
CREATE VIEW inventory."supplierItemView" AS
 SELECT "supplierItem"."supplierId",
    "supplierItem".name AS "supplierItemName",
    "supplierItem"."unitSize",
    "supplierItem".unit,
    ( SELECT "bulkItemView"."processingName"
           FROM inventory."bulkItemView"
          WHERE ("bulkItemView".id = "supplierItem"."bulkItemAsShippedId")) AS "processingName",
    "supplierItem".id,
    ( SELECT "bulkItem"."bulkDensity"
           FROM inventory."bulkItem"
          WHERE ("bulkItem".id = "supplierItem"."bulkItemAsShippedId")) AS "bulkDensity"
   FROM inventory."supplierItem";
CREATE SEQUENCE inventory."supplierItem_id_seq"
    START WITH 1000
    INCREMENT BY 1
    MINVALUE 1000
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE inventory."supplierItem_id_seq" OWNED BY inventory."supplierItem".id;
CREATE TABLE inventory."supplierItem_unitConversion" (
    id integer DEFAULT public.defaultid('inventory'::text, 'supplierItem_unitConversion'::text, 'id'::text) NOT NULL,
    "entityId" integer NOT NULL,
    "unitConversionId" integer NOT NULL
);
CREATE SEQUENCE inventory.supplier_id_seq
    START WITH 1000
    INCREMENT BY 1
    MINVALUE 1000
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE inventory.supplier_id_seq OWNED BY inventory.supplier.id;
CREATE TABLE inventory."unitConversionByBulkItem" (
    "bulkItemId" integer NOT NULL,
    "unitConversionId" integer NOT NULL,
    "customConversionFactor" numeric NOT NULL,
    id integer DEFAULT public.defaultid('inventory'::text, 'unitConversionByBulkItem'::text, 'id'::text) NOT NULL
);
CREATE TABLE master."accompanimentType" (
    id integer DEFAULT public.defaultid('master'::text, 'accompanimentType'::text, 'id'::text) NOT NULL,
    name text NOT NULL
);
CREATE TABLE master."allergenName" (
    id integer DEFAULT public.defaultid('master'::text, 'allergenName'::text, 'id'::text) NOT NULL,
    name text NOT NULL,
    description text
);
CREATE TABLE master."cuisineName" (
    name text NOT NULL,
    id integer DEFAULT public.defaultid('master'::text, 'cuisineName'::text, 'id'::text) NOT NULL
);
CREATE TABLE master."processingName" (
    id integer DEFAULT public.defaultid('master'::text, 'processingName'::text, 'id'::text) NOT NULL,
    name text NOT NULL,
    description text
);
CREATE TABLE master."productCategory" (
    name text NOT NULL,
    "imageUrl" text,
    "iconUrl" text,
    "metaDetails" jsonb,
    "importHistoryId" integer
);
CREATE TABLE master.unit (
    id integer DEFAULT public.defaultid('master'::text, 'unit'::text, 'id'::text) NOT NULL,
    name text NOT NULL
);
CREATE TABLE master."unitConversion" (
    id integer DEFAULT public.defaultid('master'::text, 'unitConversion'::text, 'id'::text) NOT NULL,
    "inputUnitName" text NOT NULL,
    "outputUnitName" text NOT NULL,
    "conversionFactor" numeric NOT NULL,
    "bulkDensity" numeric,
    "isCanonical" boolean DEFAULT false
);
COMMENT ON COLUMN master."unitConversion"."bulkDensity" IS 'kg/l';
COMMENT ON COLUMN master."unitConversion"."isCanonical" IS 'is standard?';
CREATE TABLE notifications."displayNotification" (
    id uuid DEFAULT public.gen_random_uuid() NOT NULL,
    "typeId" uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    content jsonb NOT NULL,
    seen boolean DEFAULT false NOT NULL
);
CREATE TABLE notifications."emailConfig" (
    id uuid DEFAULT public.gen_random_uuid() NOT NULL,
    "typeId" uuid NOT NULL,
    template jsonb,
    email text NOT NULL,
    "isActive" boolean DEFAULT true NOT NULL
);
CREATE TABLE notifications."printConfig" (
    id uuid DEFAULT public.gen_random_uuid() NOT NULL,
    "printerPrintNodeId" integer,
    "typeId" uuid NOT NULL,
    "isActive" boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    template jsonb NOT NULL
);
CREATE TABLE notifications."smsConfig" (
    id uuid DEFAULT public.gen_random_uuid() NOT NULL,
    "typeId" uuid NOT NULL,
    template jsonb,
    "phoneNo" text NOT NULL,
    "isActive" boolean DEFAULT true NOT NULL
);
CREATE TABLE notifications.type (
    id uuid DEFAULT public.gen_random_uuid() NOT NULL,
    name text NOT NULL,
    description text,
    app text NOT NULL,
    "table" text NOT NULL,
    schema text NOT NULL,
    op text NOT NULL,
    fields jsonb NOT NULL,
    "isActive" boolean DEFAULT false NOT NULL,
    template jsonb NOT NULL,
    "isLocal" boolean DEFAULT true NOT NULL,
    "isGlobal" boolean DEFAULT true NOT NULL,
    "playAudio" boolean DEFAULT false,
    "audioUrl" text,
    "webhookEnv" text DEFAULT 'WEBHOOK_DEFAULT_NOTIFICATION_HANDLER'::text,
    "emailFrom" jsonb DEFAULT '{"name": "", "email": ""}'::jsonb
);
CREATE TABLE "onDemand".brand_collection (
    "brandId" integer NOT NULL,
    "collectionId" integer NOT NULL,
    "isActive" boolean DEFAULT true NOT NULL,
    "importHistoryId" integer
);
CREATE TABLE "onDemand".category (
    name text NOT NULL,
    id integer DEFAULT public.defaultid('onDemand'::text, 'category'::text, 'id'::text) NOT NULL
);
CREATE TABLE "onDemand".collection (
    id integer DEFAULT public.defaultid('onDemand'::text, 'collection'::text, 'id'::text) NOT NULL,
    name text,
    "startTime" time without time zone,
    "endTime" time without time zone,
    rrule jsonb,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    "importHistoryId" integer
);
CREATE VIEW "onDemand"."collectionDetails" AS
 SELECT collection.id,
    collection.name,
    collection."startTime",
    collection."endTime",
    collection.rrule,
    "onDemand"."numberOfCategories"(collection.id) AS "categoriesCount",
    "onDemand"."numberOfProducts"(collection.id) AS "productsCount",
    collection.created_at,
    collection.updated_at
   FROM "onDemand".collection;
CREATE SEQUENCE "onDemand".collection_id_seq
    START WITH 1000
    INCREMENT BY 1
    MINVALUE 1000
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE "onDemand".collection_id_seq OWNED BY "onDemand".collection.id;
CREATE TABLE "onDemand"."collection_productCategory" (
    id integer DEFAULT public.defaultid('onDemand'::text, 'collection_productCategory'::text, 'id'::text) NOT NULL,
    "collectionId" integer NOT NULL,
    "productCategoryName" text NOT NULL,
    "position" numeric,
    "importHistoryId" integer
);
CREATE TABLE "onDemand".modifier (
    id integer DEFAULT public.defaultid('onDemand'::text, 'modifier'::text, 'id'::text) NOT NULL,
    name text NOT NULL,
    "importHistoryId" integer,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);
CREATE TABLE "onDemand"."modifierCategory" (
    id integer DEFAULT public.defaultid('onDemand'::text, 'modifierCategory'::text, 'id'::text) NOT NULL,
    name text NOT NULL,
    type text DEFAULT 'single'::text NOT NULL,
    "isVisible" boolean DEFAULT true NOT NULL,
    "isRequired" boolean DEFAULT true NOT NULL,
    limits jsonb DEFAULT '{"max": null, "min": 1}'::jsonb,
    "modifierTemplateId" integer NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);
CREATE VIEW "onDemand"."modifierCategoryOptionView" AS
 SELECT "modifierCategoryOption".id,
    "modifierCategoryOption".name,
    "modifierCategoryOption"."originalName",
    "modifierCategoryOption".price,
    "modifierCategoryOption".discount,
    "modifierCategoryOption".quantity,
    "modifierCategoryOption".image,
    "modifierCategoryOption"."isActive",
    "modifierCategoryOption"."isVisible",
    "modifierCategoryOption"."operationConfigId",
    "modifierCategoryOption"."modifierCategoryId",
    "modifierCategoryOption"."sachetItemId",
    "modifierCategoryOption"."ingredientSachetId",
    "modifierCategoryOption"."simpleRecipeYieldId",
    "modifierCategoryOption".created_at,
    "modifierCategoryOption".updated_at,
    concat(( SELECT "modifierCategory".name
           FROM "onDemand"."modifierCategory"
          WHERE ("modifierCategory".id = "modifierCategoryOption"."modifierCategoryId")), ' - ', "modifierCategoryOption".name) AS "displayName"
   FROM "onDemand"."modifierCategoryOption";
CREATE TABLE "order"."cartItem" (
    id integer DEFAULT public.defaultid('order'::text, 'cartItem'::text, 'id'::text) NOT NULL,
    "cartId" integer,
    "parentCartItemId" integer,
    "isModifier" boolean DEFAULT false NOT NULL,
    "productId" integer,
    "productOptionId" integer,
    "comboProductComponentId" integer,
    "customizableProductComponentId" integer,
    "simpleRecipeYieldId" integer,
    "sachetItemId" integer,
    "isAssembled" boolean DEFAULT false NOT NULL,
    "unitPrice" numeric DEFAULT 0 NOT NULL,
    "refundPrice" numeric DEFAULT 0 NOT NULL,
    "stationId" integer,
    "labelTemplateId" integer,
    "packagingId" integer,
    "instructionCardTemplateId" integer,
    "assemblyStatus" text DEFAULT 'PENDING'::text NOT NULL,
    "position" numeric,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    "isLabelled" boolean DEFAULT false NOT NULL,
    "isPortioned" boolean DEFAULT false NOT NULL,
    accuracy numeric DEFAULT 5,
    "ingredientSachetId" integer,
    "isAddOn" boolean DEFAULT false NOT NULL,
    "addOnLabel" text,
    "addOnPrice" numeric,
    "isAutoAdded" boolean DEFAULT false NOT NULL,
    "inventoryProductBundleId" integer,
    "subscriptionOccurenceProductId" integer,
    "subscriptionOccurenceAddOnProductId" integer,
    "packingStatus" text DEFAULT 'PENDING'::text NOT NULL,
    "modifierOptionId" integer,
    "subRecipeYieldId" integer,
    status text DEFAULT 'PENDING'::text NOT NULL
);
CREATE TABLE products."productOptionType" (
    title text NOT NULL,
    description text,
    "orderMode" text NOT NULL
);
